왜 도입했는가?
공통 처리가 어렵다.
기능이 복잡해질 수 록 컨트롤러에서 공통으로 처리해야 하는 부분이 점점 더 많이 증가할 것이다. 단순히 공통 기능을 메서드로 뽑으면 될 것 같지만, 결과적으로 해당 메서드를 항상 호출해야 하고, 실수로 호출하지 않으면 문제가 될 것이다.

![[Pasted image 20231103230513.png]]
도입 후
![[Pasted image 20231103230545.png]]
FrontController 패턴 특징
프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음 
프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출 
입구를 하나로! 
공통 처리 가능
프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨


첫 구조 V1
![[Pasted image 20231103231010.png]]
프론트 컨트롤러에서 컨트롤러의 요청에 대해서 map으로써 해당 컨트롤러를 찾아준다.

문제: 컨트롤러 로직에서 아직 까지는 viewPath가 각각 컨트롤러 마다 중복이 되어있다 이를 개선하는 v2 구조를 보자

두 번째 구조  v2
![[Pasted image 20231103231943.png]]
이런식의 구조를 만들게 되면 

```java
public void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException 
{ 
RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request, response);
}
```

이렇게 해당 각각의 컨트롤러 마다 해당 뷰 path로 이동하는 이 로직의 코드를 줄일 수 있다. 중복이 제거된다. 결국은 컨트롤러가 뷰를 반환하는 특징이 나온다. 그렇게 되면 프론트 컨트롤러에서 다시 반환된 뷰를 가지고 render(request.response)를 호출하면 위의 로직이 jsp파일로 이동하게 된다.
>[!important]
문제: 아직까지는 컨트롤러에 서블릿 기술이 종속되어져 있다 즉
HttpServletRequest, HttpServletResponse 이 부분이 있다. 
또한 그리고 또한 기존의 서블릿으로 개발했을 때는 request 객체를 Model로써 사용하였다 결국 위에(HttpServletRequest, HttpServletResponse) 부분을 이제 사용하지 않기도 하고 대신에 별도의 Model 객체를 만들어서 반환하면 된다.  이 부분이 컨트롤러 입장에서 없애는 방식인 v3 구조를 살펴보자 

>[!important]
>또한 뷰 이름들도 아직 앞의 경로들이 중복되어져 있다 . 즉 뷰의 물리적 위치의 이름까지 아직 중복 되어져 있다 이를 프론트 컨트롤러에서 처리하도록 하자 

세 번째 구조 v3
![[Pasted image 20231103234901.png]]


이번 구조에서는